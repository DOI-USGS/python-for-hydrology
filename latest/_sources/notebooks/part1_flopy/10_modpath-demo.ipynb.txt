{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "from IPython.display import clear_output, display\n",
    "import pathlib as pl\n",
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "import geopandas as gpd\n",
    "from flopy.utils.gridintersect import GridIntersect\n",
    "import flopy\n",
    "import pandas as pd"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Groundwater Modeling and Python Programming\n",
    "\n",
    "In this exercise, we will use MODPATH to simulate advective transport with the Freyberg flow model. For this exercise, we will use a quadtree version of the Freyberg model.\n",
    "\n",
    "The location of the contamination patch and the nodes that the define bounding cells of the patch are calculated below."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# patch upper left and lower right\n",
    "xmin, xmax = 250. * 1, 250. * 3\n",
    "ymin, ymax = (40 - 14) * 250., (40 - 11) * 250. \n",
    "\n",
    "csx, csy = [xmin, xmin, xmax, xmax, xmin], [ymin, ymax, ymax, ymin, ymin]\n",
    "polygon = [list(zip(csx, csy))]\n",
    "(xmin, ymax), (xmax, ymin)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "--------------------------\n",
    "\n",
    "### Define the workspace and model names."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "load_ws = pl.Path('data/quadtree')\n",
    "ws = pl.Path(\"temp/ex10a\")\n",
    "name = \"project\"\n",
    "name_mp = f\"{name}_mp\"\n",
    "exe_name = 'mf6'"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Load the MODFLOW 6 Model\n",
    "\n",
    "Load a simulation object using `flopy.mf6.MFSimulation().load()`."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "sim = flopy.mf6.MFSimulation.load(sim_name=name, exe_name=exe_name,\n",
    "                                    sim_ws=load_ws)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Load the groundwater flow model"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "gwf = sim.get_model(name)\n",
    "gwf.modelgrid"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Change the workspace"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "sim.set_sim_path(ws)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Write the model files"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "sim.write_simulation()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Run the simulation."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "sim.run_simulation()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Create and Run the MODPATH model\n",
    "\n",
    "\n",
    "### Lets plot the model grid and the location of the contamination patch."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "fig, ax = plt.subplots(figsize=(5, 9))\n",
    "mm = flopy.plot.PlotMapView(gwf, layer=0, ax=ax)\n",
    "\n",
    "mm.plot_bc('SFR', color=\"b\", plotAll=True)\n",
    "mm.plot_bc('WEL', plotAll=True)\n",
    "mm.plot_inactive(alpha=0.75)\n",
    "\n",
    "mm.plot_grid(lw=0.25, color='grey')\n",
    "\n",
    "ax.fill(csx, csy, color='#e534eb');"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Find the node numbers of the contamination patch using the groundwater model grid object and the `GridIntersect` utility. The `GridIntersect` utility has an `intersect` method that can be used to identified cellids from points, lines, and polygons."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "gx = GridIntersect(gwf.modelgrid)\n",
    "results = gx.intersect(polygon, 'Polygon')\n",
    "nodes = results.cellids\n",
    "nodes"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Create the MODPATH particle data"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# create\n",
    "sd = flopy.modpath.CellDataType()\n",
    "p = flopy.modpath.NodeParticleData(subdivisiondata=[sd],\n",
    "                                   nodes=list(nodes))\n",
    "# create forward particle group\n",
    "fpth = name_mp + '.sloc'\n",
    "pg = flopy.modpath.ParticleGroupNodeTemplate(particlegroupname='contaminant',\n",
    "                                             particledata=p,\n",
    "                                             filename=fpth)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Create the MODPATH 7 files"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# create modpath files\n",
    "mp = flopy.modpath.Modpath7(modelname=name_mp, flowmodel=gwf,\n",
    "                            exe_name='mp7', model_ws=ws)\n",
    "mpbas = flopy.modpath.Modpath7Bas(mp, porosity=0.1)\n",
    "mpsim = flopy.modpath.Modpath7Sim(mp, simulationtype='pathline', \n",
    "                                  trackingdirection='forward',\n",
    "                                  weaksinkoption='pass_through',\n",
    "                                  weaksourceoption='pass_through',\n",
    "                                  referencetime=0.,\n",
    "                                  stoptimeoption='extend',\n",
    "                                  particlegroups=pg)\n",
    "help(flopy.modpath.Modpath7Sim)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Write MODPATH 7 files and run the model"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# write modpath datasets\n",
    "mp.write_input()\n",
    "\n",
    "# run modpath\n",
    "mp.run_model()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Post-Process the MODFLOW and MODPATH Results\n",
    "\n",
    "\n",
    "### Load MODFLOW and MODPATH results from the heads and pathline files\n",
    "\n",
    "Load the MODFLOW heads"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "hobj = gwf.output.head()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "hds = hobj.get_data()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Load the pathline file"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "ppth =ws / f\"{name_mp}.mppth\"\n",
    "p = flopy.utils.PathlineFile(ppth)\n",
    "p0 = p.get_alldata()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "p0"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Plot the heads and pathlines"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "fig, ax = plt.subplots(figsize=(5, 9))\n",
    "mm = flopy.plot.PlotMapView(model=gwf, layer=0, ax=ax)\n",
    "mm.plot_array(hds, masked_values=[1e30])\n",
    "\n",
    "mm.plot_bc('SFR', color='b', plotAll=True)\n",
    "mm.plot_bc('WEL', plotAll=True)\n",
    "mm.plot_ibound()\n",
    "mm.plot_pathline(p0, layer='all', color='blue', lw=1)\n",
    "mm.plot_grid(lw=0.2, color=\"0.5\")\n",
    "\n",
    "ax = plt.gca()\n",
    "ax.fill(csx, csy, color='#e534eb', zorder=100, alpha=.75);"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "fig, ax = plt.subplots(figsize=(5, 9))\n",
    "\n",
    "mm = flopy.plot.PlotMapView(model=gwf, ax=ax, layer=0)\n",
    "mm.plot_array(hds, masked_values=[1e30])\n",
    "mm.plot_bc('SFR', color='b', plotAll=True)\n",
    "mm.plot_bc('WEL', plotAll=True)\n",
    "mm.plot_ibound()\n",
    "mm.plot_grid(lw=0.2, color=\"0.5\")\n",
    "\n",
    "p = flopy.utils.PathlineFile(ppth)\n",
    "p0 = p.get_alldata()\n",
    "df = pd.DataFrame.from_records(p0[0])\n",
    "for ix, recarray in enumerate(p0):\n",
    "    dft = pd.DataFrame.from_records(recarray)\n",
    "    df = pd.concat((df, dft), ignore_index=True)\n",
    "vmin, vmax = df.time.min(), df.time.max()\n",
    "\n",
    "times = list(range(0, 74001, 1000))\n",
    "for ix in range(1, len(times)):\n",
    "    tmp = df[(df.time >= times[ix - 1]) & (df.time < times[ix])]\n",
    "    s = ax.scatter(tmp.x.values, tmp.y.values, c=tmp.time.values, vmin=vmin, vmax=vmax, cmap=\"magma\")\n",
    "    ax.set_title(f\"{times[ix - 1]} - {times[ix]} days\")\n",
    "    display(fig)\n",
    "    clear_output(wait=True)\n",
    "    plt.pause(0.1)    "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Export the pathlines to a shapefile"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "spth = pl.Path(ws / 'pathline.shp')\n",
    "p.write_shapefile(p0, mg=gwf.modelgrid, one_per_particle=False, shpname=spth)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Load the shapefile into geopandas"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "rshp = gpd.read_file(spth)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Show the dataframe"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "rshp"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Plot the geopandas dataframe on the modelgrid"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "fig, ax = plt.subplots(figsize=(6, 10))\n",
    "pmv = flopy.plot.PlotMapView(gwf, ax=ax)\n",
    "pmv.plot_grid(lw=0.5)\n",
    "pmv.plot_shapes(rshp.geometry.to_list(), edgecolor=\"grey\") #, edgecolor=\"b\")\n",
    "pmv.plot_ibound();"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Export the data to VTK (Visualization ToolKit) format for a 3d representation\n",
    "\n",
    "FloPy's `Vtk` module allows us to create Visualization ToolKit (VTK) files that can be opened and explored with pyVISTAs or external software such as ParaView."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "from flopy.export.vtk import Vtk\n",
    "\n",
    "vtk = Vtk(model=gwf, binary=False, vertical_exageration=50, smooth=False)\n",
    "vtk.add_model(gwf)\n",
    "vtk.add_pathline_points(p0)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Write VTK file for use in ParaView or other VTK software"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "pth = pl.Path(\"temp\")\n",
    "pth.mkdir(exist_ok=True)\n",
    "\n",
    "vtk.write(pth)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Alternatively we can visualize the VTK representation using `pyvista`"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import pyvista as pv"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Convert the VTK to pyvista meshes and rotate the meshes to match the orientation of our matplotlib plots"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "grid, pathlines = vtk.to_pyvista()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "axes = pv.Axes(show_actor=True, actor_scale=2.0, line_width=5)\n",
    "\n",
    "grid.rotate_z(160, point=axes.origin, inplace=True)\n",
    "pathlines.rotate_z(160, point=axes.origin, inplace=True)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Select particle release locations and build a dictionary of particle tracks (pathlines). This will be used below for particle labelling, as well as for animation.\n",
    "\n",
    "*Note*: while below we construct pathlines manually from data read from the exported VTK files, pathlines may also be read directly from the MODPATH 7 pathline output file (provided the simulation was run in pathline or combined mode, as this one was)."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "tracks = {}\n",
    "particle_ids = set()\n",
    "release_locs = list()\n",
    "\n",
    "for i, t in enumerate(pathlines[\"time\"]):\n",
    "    pid = str(round(float(pathlines[\"particleid\"][i])))\n",
    "    loc = pathlines.points[i]\n",
    "\n",
    "    if pid not in tracks:\n",
    "        tracks[pid] = []\n",
    "        particle_ids.add(pid)\n",
    "        release_locs.append(loc)\n",
    "\n",
    "    # store the particle location in the corresponding track\n",
    "    tracks[pid].append((loc, t))\n",
    "\n",
    "release_locs = np.array(release_locs)\n",
    "tracks = {k: np.array(v, dtype=object) for k, v in tracks.items()}\n",
    "max_track_len = max([len(v) for v in tracks.values()])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "View the grid and pathlines with PyVista, with particle tracks/locations colored by time. Also add particle ID labels to a few particles’ release locations."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "pv.set_plot_theme(\"document\")\n",
    "pv.set_jupyter_backend(\"static\")\n",
    "\n",
    "# create the plot and add the grid and pathline meshes\n",
    "p = pv.Plotter()\n",
    "p.add_mesh(grid, opacity=0.05)\n",
    "p.add_mesh(pathlines, scalars=\"time\")\n",
    "\n",
    "# add a particle ID label to each 20th particle's starting point\n",
    "label_coords = []\n",
    "start_labels = []\n",
    "for pid, track in tracks.items():\n",
    "    if int(pid) % 20 == 0:\n",
    "        label_coords.append(track[0][0])\n",
    "        start_labels.append(f\"Particle {pid}\")\n",
    "\n",
    "p.add_point_labels(\n",
    "    label_coords,\n",
    "    start_labels,\n",
    "    font_size=10,\n",
    "    point_size=15,\n",
    "    point_color=\"black\",\n",
    ")\n",
    "\n",
    "# zoom in and show the plot\n",
    "p.camera.zoom(2.4)\n",
    "p.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Create an animated GIF of the particles traveling along their pathlines, with particles colored by time."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# create plotter\n",
    "p = pv.Plotter(notebook=False, off_screen=True)\n",
    "\n",
    "# open GIF file\n",
    "gif_path = pth / f\"freyberg_tracks.gif\"\n",
    "p.open_gif(str(gif_path))\n",
    "\n",
    "# create mesh from release locations\n",
    "spls = pv.PolyData(release_locs)\n",
    "spls.point_data[\"time\"] = np.zeros(len(spls.points))\n",
    "\n",
    "# add the underlying grid mesh and particle data, then zoom in\n",
    "p.add_mesh(grid, opacity=0.05)\n",
    "p.add_mesh(spls, clim=[0, 1.23e09])\n",
    "p.camera.zoom(2.4)\n",
    "\n",
    "# cycle through time steps and update particle location\n",
    "for i in range(1, max_track_len):\n",
    "    pts = []\n",
    "    times = []\n",
    "    segments = []\n",
    "\n",
    "    for pid in particle_ids:\n",
    "        track = tracks[pid]\n",
    "        npts = len(track)\n",
    "        # use last locn if particle has already terminated\n",
    "        loc, t = track[i] if i < npts else track[npts - 1]\n",
    "        pts.append(loc)\n",
    "        times.append(t)\n",
    "        if i < npts:\n",
    "            segments.append(track[i - 1][0])\n",
    "            segments.append(loc)\n",
    "\n",
    "    p.update_coordinates(np.vstack(pts), render=False)\n",
    "    p.update_scalars(np.array(times), mesh=spls, render=False)\n",
    "    p.add_lines(np.array(segments), width=1, color=\"black\")\n",
    "    p.write_frame()  # write frame to file\n",
    "\n",
    "# close the plotter and the GIF file\n",
    "p.close()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "from IPython.core.display import Image\n",
    "\n",
    "display(Image(data=open(gif_path, \"rb\").read(), format=\"gif\"))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.9.12"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
